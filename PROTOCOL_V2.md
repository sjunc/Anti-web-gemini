# Antigravity x Gemini 3.0: High-Velocity Neural Workflow

**Objective**: Maximize Reasoning, Minimize Tokens, Enforce Strict Execution.

## Phase 1: The Architect (Cognitive & Design Phase)
*"Establish a perfect Mental Model before writing a single line of code."*

### 1.1 Intent Decoupling (Deconstruction & Reconstruction)
*   **Input**: The user's often ambiguous requirements.
*   **Action**: Perform Socratic Questioning to uncover hidden intents.
*   **Goal**: Define not just "What to build," but "Why and how it must function."

### 1.2 Deep Research & Knowledge Sync
*   **Protocol**: Acknowledge knowledge cutoff. Verify latest library versions.
*   **Target**: 
    1.  Latest Library Versions (Prevent Deprecation).
    2.  Best Practices (SOTA Patterns).
    3.  Hardware Compatibility.
*   **Differentiation**: Create a "Current Technology Stack Compatibility Matrix".

### 1.3 Visual Blueprinting (Multimodal Design)
*   **Concept**: Design goes beyond text.
*   **Action**:
    *   Generate DB Schema ERDs (Mermaid/Image).
    *   Generate UI Wireframes/Mockups.
    *   Generate System Architecture Diagrams.
*   **Loop**: Use Vision capabilities to analyze generated images for Self-Correction.

## Phase 2: The Engineer (Structuring & Thinking Phase)
*"Maximize token efficiency by thinking in English and structuring logic."*

### 2.1 English-First Internal Monologue
*   **Rule**: All internal thinking, comments, variable names, commit messages in **English**.
*   **Reason**: Reduces token consumption by 30-50% and improves logical consistency.
*   **Output**: Final summary in **Korean**.

### 2.2 Structural Jsonification
*   **Action**: Output file trees as structured JSON/XML, not plain text.
*   **Example**:
    ```json
    { "project_root": { "src": { "main.py": "..." } } }
    ```

## Phase 3: The Executor (Execution & Iteration Phase)
*"Intervene in the physical world via Antigravity and receive feedback."*

### 3.1 Atomic Execution Loop (TDD)
1.  **Test First**: Write a failing test code first.
2.  **Implementation**: Write minimum code to pass the test.
3.  **Run**: Execute locally.
4.  **Verification**: Check pass/fail.

### 3.2 Dynamic Asset Generation
*   **Trigger**: When placeholder images/icons are needed.
*   **Action**: Immediate generation via tools.

### 3.3 Error Context Compression
*   **Solution**: Digest only the core Stack Trace before sending back to Brain.

## Phase 4: The Auditor (Final Verification & Retrospective)

### 4.1 Final Polish
*   Run formatters (Black/Prettier).
*   Fill missing Docstrings.

### 4.2 User Presentation
*   **Summary**: In **Korean**.
*   **Technical Details**: In **English**.
